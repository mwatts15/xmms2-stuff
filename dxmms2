#!/usr/bin/env ruby
require 'xmmsclient'
require 'uri'
require 'socket'
##########################
# simple xmms2 script    #
# for dmenu              #
##########################

$COMMAND_SIG = "@"
# default configs {{{
$SCREEN_WIDTH=600
$FONT_WIDTH=14 #in pixels
$BG_COLOR='"#000000"'
$FG_COLOR='"#dc322f"'
$SEL_BG_COLOR=$FG_COLOR
$SEL_FG_COLOR=$BG_COLOR
$FONT='"Sazanami Mincho":pixelsize=' + $FONT_WIDTH.to_s
$LIST_ENTRIES_PER_PAGE = 15
# }}}

#if [ -e $CONFIG ] ; then
    #source $CONFIG
#fi
class Integer
    def ms_to_time_string
        minutes=(self / 60000)
        seconds=(self % 60000) / 1000
        "%d:%02d" % [minutes, seconds]
    end
end

def time_string_to_ms(str)
    res = 0
    s = 1
    for n in str.split(":").reverse do
        s = 60 * s
        res = res + s * (n.to_i)
    end
    return res.to_i
end

class String
    def initialize
        super
        force_encoding("utf-8")
    end
    def alignr(r, w)
        str = self + r.rjust(Rational(w, $FONT_WIDTH) - r.kanji_off - self.kanji_off - self.length + Integer(w / $FONT_WIDTH) - 2, '.') #+ " #{w/ $FONT_WIDTH}"
        #puts str
        str
    end
    def kanji_off
        # Gives me the number of spaces "missing" with double-width
        # kanji characters. Used for formatting adjustment
        (self.bytes.count - self.length) / 2
    end

    def to_perc
        if self.ends_width("%")
            self.to_f / 100.0
        else
            self.to_f * 100
        end
    end
    def scrunch(size,dots='...')
        #self.force_encoding("utf-8")
        #puts "Scrunching"
        if self.length < size
            #puts "Well, that was pointless"
            self
        else
            sidelen = (size - dots.length - self.kanji_off) / 2
            # Not centered; intentional
            self[0..sidelen] + dots + self[-sidelen..-1]
        end
    end
    alias :| alignr
end

def my_dmenu (entries, prompt='dxmms2', height=entries.count, width=$SCREEN_WIDTH)
    res = ""
    height = [height, 20].min
    entries.collect! do |line|
        l, r = line.split("|||")
        #puts "width=" + width.to_s
        r ? l.alignr(r.scrunch(width / $FONT_WIDTH), width) : l
    end
    cmdline = "dmenu -f -p \"#{prompt}\" -nf #{$FG_COLOR} \
    -nb #{$BG_COLOR} \
    -sb #{$SEL_BG_COLOR} \
    -sf #{$SEL_FG_COLOR} \
    -i -l #{height} \
    -w #{width} \
    -fn #{$FONT}"
    IO.popen(cmdline, "w+") do |io|
        io.print(entries.join("\n"))
        io.close_write
        res = io.gets
    end
    res.to_s.chomp
end

# returns a hash of the passed in fields
# with the top values for the fields
def extract_medialib_info(id, *fields)
    infos = $xc.medialib_get_info(id).wait.value
    res = Hash.new
    fields = fields.map! {|f| f.to_sym }
    fields.each do |field|
        values = infos[field]
        if not values.nil?
            my_value = values.first[1] # actual value from the top source [0]
            if field == :url
                my_value = decode_xmms2_url(my_value)
            end
            res[field] = my_value.to_s.force_encoding("utf-8")
        end
    end
    res
end

def pl_list(start=nil,nentries=nil,prompt="Track: ")
    entries = $pl.entries.wait.value
    current = $pl.current_pos.wait.value
    cur = current.nil? ? 0 : current[:position] 
    start = start.nil? ? cur : start
    list_ids(entries,prompt,start,nentries)
end

def list_ids(entries,prompt,start=0,nentries=nil, commands=Hash.new)
    # XXX: Create a list object to pass to user-supplied commands
    #      list object allows for setting list start, page size, list content, whether to redisplay the list, and maybe other things
    morestring,endstring,startstring,backstring = 
        %w[more end start back].map{|w| $COMMAND_SIG + w}
    c1 = Hash.new
    commands.each do |k,v|
        c1["@"+k] = v
    end
    listing=1
    nentries = (nentries.nil? ? $LIST_ENTRIES_PER_PAGE : nentries)
    pos = nil
    list_start = start
    while ( listing == 1 ) do
        start_clamped = false
        end_clamped = false
        items = Array.new

        #clamps start
        (list_start <= 0) and (list_start = 0 ; start_clamped = true)

        list_end = list_start + nentries

        #clamps end
        (list_end > entries.length) and (list_end = entries.length ; end_clamped = true)


        nw = list_end.to_s.length
        i = list_start

        if not start_clamped
            items << backstring
            items << startstring
        end

        items += xmms2_ids_to_display_list_strings(entries[list_start..list_end]).map do |string|
            string = "#{i.to_s.rjust(nw)}. #{string}"
            i += 1
            string
        end

        if not end_clamped
            items << endstring
            items << morestring
        end

        c1.keys.each do |d|
            items << d
        end

        choice = my_dmenu(items, prompt, items.length).gsub(/^\s+|\s+$/, "")
        pos = choice[/^-?\d+|#{$COMMAND_SIG}\w+/]

        case pos
        when backstring
            list_start -= nentries
        when morestring
            list_start += nentries
        when endstring
            list_start = entries.length - nentries
        when startstring
            list_start = 0
        when *(c1.keys)
            f = c1[pos]
            f.call(entries)
            listing = 0
        else
            listing = 0
        end
    end
    if pos.nil? then return nil end

    pos = pos.to_i
    if pos < 0 then entries.length + pos else pos end
end

def xmms2_ids_to_display_list_strings(ids, fields=%w[artist title url duration])
    ids.map do |id| 
        my_info = extract_medialib_info(id, *fields)
        artist_part = my_info[:artist]
        some_title = (my_info[:title] or File.basename(my_info[:url]))
        duration = my_info[:duration].to_i.ms_to_time_string
        "#{artist_part}|||#{some_title} [#{duration}]"
    end
end

def decode_xmms2_url (url)
    URI.decode_www_form_component(url)
    #echo "$(perl -MURI::Escape -e 'print uri_unescape($ARGV[0]);' "$url")" 
end

def get_usertags(id)
    info = extract_medialib_info(id, :usertags)
    if info.has_key?(:usertags)
        info[:usertags].lines.to_a
    else
        []
    end
end

def set_tags(id, tags)
    $xc.medialib_entry_property_set(id, :usertags, tags.map{|x| x.chomp}.uniq.join("\n")).wait
end

def tag_track(id, tag)
    tags = get_usertags(id) << tag.chomp
    set_tags(id, tags)
end

def untag_track(id, tag)
    tags = get_usertags(id).reject{|x|x==tag}
    set_tags(id, tags)
end

def tag_menu(ids, previous_tags)
    tag_file = File.join(Xmms::userconfdir, 'usertags')
    all_tags = File.new(tag_file,File::CREAT).to_a

    previous_tags = previous_tags.map{|x| x.chomp}

    tag_list = previous_tags.map{|k| "!" + k} + all_tags
    tag_list.map!{|x| x.chomp}

    tag = my_dmenu(tag_list, "Add/delete a tag")
    if (!tag.empty?)
        Thread.new do 
            if (tag[0] == "!")
                ids.each do |id|
                    untag_track(id, tag[1..-1])
                end
            else
                ids.each do |id|
                    tag_track(id, tag)
                end
            end
        end


        if (tag[0] != "!")
            all_tags << tag + "\n"
            all_tags.uniq!
        end
        File.open(tag_file, "w") do |file|
            all_tags.each do |t|
                file.write(t)
            end
        end
        tag
    else
        nil
    end
end

def get_album_ids(id)
    album_name = extract_medialib_info(id, :album)[:album]
    album_coll = match_collection('album', album_name)

    $xc.coll_query_ids(album_coll).wait.value
end

def match_collection(field, pattern)
    coll = Xmms::Collection.new(Xmms::Collection::TYPE_MATCH)
    coll.operands << Xmms::Collection.universe
    coll.attributes["field"] = field
    coll.attributes["value"] = pattern
    coll
end

# The idea of this is that if I like a song around the middle of the track, I think it's a
# really good song and it's probably new since I had to listen halfway through to decide
# I liked it. I also consider that there may be an over-eagerness in my reaction early in
# a track, so I penalize that. Lastly, for me, if I like the track near the end, I'm only 
# sort-of listening to it or only like it enough to appreciate it as a whole, but can't
# say much for it in parts.
#
# This should only be used additively with past `likes'
def track_appreciation_factor(playtime, track_duration)
    k = [0, [playtime, track_duration].min].max.to_f / track_duration - 0.5
    l = 1.0 - k.abs
    l
end

$commands=%w<toggle list +fav +fav-album 
tag tag-album prev next stop 
info change-playlist clear edit-metadata search 
shuffle repeat-playlist repeat-track repeat-off remove 
shutdown seek>

$xc = Xmms::Client.new("dxmms2")
begin
$xc.connect()
rescue Xmms::Client::ClientError => e
    $stderr.puts e
    `xmms2-launcher`
    ntries = 1
    while $? != 0
        if ntries > 4
            exit "Can't start xmms2d. Exiting."
        end
        $stderr.puts "Coludn't start the daemon, trying again..."
        sleep 3
        `xmms2-launcher -vvvv`
        ntries += 1
    end
    $xc.connect()
    $stderr.puts "Connected."
end
$pl = $xc.playlist

while (true) do
    command = my_dmenu($commands).chomp
    case command
        # NOTE: The *break statements* in here are for the *while loop*
        #       not for the switch
    when "list"
        pos = pl_list(nil, nil, "Play Track:")
        if not pos.nil?
            puts "moving to positon #{pos}"
            res = $xc.playlist_set_next(pos).wait.value
            #puts res
            $xc.playback_tickle.wait
            $xc.playback_stop.wait
            $xc.playback_start.wait
        end
        break
    when "info"
        entries = $pl.entries.wait.value
        if not entries.nil?
            pos = pl_list(nil,nil,"Track Info:")
            id = entries[pos]
            info = extract_medialib_info(id, *%w<artist title album tracknr favorite timesplayed url date duration laststarted added usertags comment>)
            info = Hash[info.map { |k,v| 
                k = k.to_s
                if %w<duration>.include?(k) 
                    v = [v.to_i.ms_to_time_string, v]
                elsif %w<laststarted added lmod>.include?(k)
                    v = [Time.at(v.to_i).strftime("%F"), v]
                elsif k == "usertags"
                    v = [v.gsub(%r{\n}, ", ")]
                else
                    v = [v]
                end
                [k,v]
            }]
            while true
                field = my_dmenu(info.map {|k,v| "#{k} |||#{v[0]}"}, "Info", info.size)
                if field.empty?
                    break
                else
                    field = field[/^[^ ]+/]
                    values = info[field]
                    if values.length > 1
                        value = my_dmenu(values.map{ |v| v.to_s }, "Version?")
                    else
                        value = values[0]
                    end
                    operation = my_dmenu(%w<copy back>, value) 
                    case operation
                    when "copy"
                        `echo '#{value}' | xsel --clipboard -i`
                        break
                    when "back"
                    else
                        break
                    end
                end
            end
        end
        break
    when "search"
        fields = ["artist", "title", "genre", "album"]
        choice = my_dmenu(fields, prompt="Field")
        # XXX: Save and display past searches
        search_string = my_dmenu([],prompt="Search string")
        coll = match_collection(choice, search_string)
        d = $xc.coll_query_ids(coll).wait.value
        def add(ids)
            ids.each do |z|
                $pl.add_entry(z).wait
            end
        end
        cs = Hash.new 
        cs["add"] = proc { |k| add(k) } # thunk it!
        list_ids(d, prompt="Results", start=0, nentries=$LIST_ENTRIES_PER_PAGE, commands=cs)
        break
    when "remove"
        while true
            pos = pl_list(nil,nil,"Remove entry:")
            if pos.nil?
                break
            else
                $pl.remove_entry(pos).wait
            end
        end
        break
    when "+fav"
        begin
            id = $xc.playback_current_id.wait.value
            p = $xc.playback_playtime.wait.value
            data = extract_medialib_info(id, :favorite, :duration)
            old_favorite = data[:favorite].to_f
            duration = data[:duration].to_i
            appreciation = track_appreciation_factor(p, duration)
            $xc.medialib_entry_property_set(id, :favorite, (old_favorite+appreciation).to_s).wait
        end
        break
    when "+fav-album"
        id = $xc.playback_current_id.wait.value
        get_album_ids(id).each do |al_id|
            old_favorite = extract_medialib_info(al_id, :favorite)[:favorite].to_f
            $xc.medialib_entry_property_set(al_id, :favorite, old_favorite+1).wait
        end
        break
    when "tag"
        # TODO: refcount the tags in the tag file so they get removed
        # when no file is tagged with them

        id = $xc.playback_current_id.wait.value
        while tag_menu([id], get_usertags(id))
        end

        break
    when "tag-album"
        begin
            album_ids = get_album_ids(id)
            while tag_menu(album_ids, [])
            end
        catch e
            puts e
        end

        break
    when "change-playlist"
        begin
            playlists = $xc.playlist_list.wait.value
            playlists = playlists.delete_if {|s| s.start_with?("_")}
            selected = my_dmenu(playlists)
            $xc.playlist(selected).load.wait
        end
        break
    when %r{repeat-(off|track|playlist)}
        case command.split(%r{-})[1]
        when "off"
            `xmms2 server config playlist.repeat_one 0`
            `xmms2 server config playlist.repeat_all 0`
        when "track"
            `xmms2 server config playlist.repeat_one 1`
            `xmms2 server config playlist.repeat_all 0`
        when "playlist"
            `xmms2 server config playlist.repeat_one 0`
            `xmms2 server config playlist.repeat_all 1`
        end
        break
    when "shuffle"
        $pl.shuffle.wait
        break
    when "shutdown"
        `xmms2 server shutdown`
        break
    when "seek"
        print $xc.playback_playtime.wait.value
        id = $xc.playback_current_id.wait.value
        info = extract_medialib_info(id, :duration)
        dur = info[:duration].to_i 
        interval_size = dur / 10
        times = []
        times << ["start",  0]
        Range.new(0,dur).step(interval_size).each do |x|
            times << [x.ms_to_time_string, x]
        end
        times << ["end", dur]
        seek_location = my_dmenu(times.map{|x| x[0]}).to_s
        # FIXME: This math is clearly janky. Sadly I have actual work to do.
        seek = 20 * time_string_to_ms(seek_location)
        puts $xc.playback_seek_ms(seek).wait.value
        $stdout.flush
        break
    else
        if not command.empty?
            `xmms2 #{command}`
        end
        break
    end
end
